一 MFC多线程
   MFC根据用途将线程分为工作者线程和用户界面线程
   1 工作者线程
     没有自己的用户界面，主要用来处理后台比较耗时的操作。
   2 用户界面线程
     拥有自己的用户界面，子线程的界面可以接受用户的消息。
   3 工作者线程的使用
     3.1 定义线程函数，函数原型：
     UINT MyControllingFunction( LPVOID pParam );
     注意：该函数要么是全局函数，要么是类的静态成员函数。
     3.2 调用AfxBeginThread()创建和启动线程，并将线程函数
     作为函数的第一个参数，如果需要主线程与子线程之间传递
     数据，可以使用第二个参数。
   4 用户界面线程
     4.1 添加CWinThread类的派生类CMyThread
     4.2 添加一个对话框类，用于子线程的界面显示
     4.3 在CMyThread类的InitInstance()函数中创建和显示对
         话框界面
     4.4 调用AfxBeginThread()创建和启动线程，并将线程类的
     运行时类信息作为函数的第一个参数

   5 线程同步类
     MFC提供了线程同步类：
     CCriticalSection/CSemphore/CEvent/CMutex
二 COM组件基础
   1 概念
   COM组件是一组可以执行的二进制代码，通过接口的方式为其它
   软件、系统或者组件提供相关的服务。
   2 程序的编写方式
   2.1 面向过程的结构化编程（以C语言为代表）
     以"业务流程"为中心，自顶向下的编写方式，划分功能模块，按照流程编写程序。这种
     编写方式可以很好的满足当前的需求，不利于项目的需求变更。
     “软件危机”
   2.2 面向对象编程（以C++、Java、C#为代表）
     以"对象"或者说"类"为中心，自底向上的编写方式。 当需求
     变更时，只需要修改相关的一个类或者几个类，不会影响到
     整个项目。整个项目编译生成一个exe程序。
   2.3 面向组件编程
     以"功能"为中心，把每个功能封装成小的二进制文件。组件
     与组件之间通过接口调用。一个项目组成：多个dll+多个exe。
     当需求变更时，只需要修改和编译相关的组件，整个工程不需要
     重新编译。
   3 组件的特点
     动态的加载和卸载、与具体的编程语言无关、使用灵活方便
   4 接口的概念
     C语言-接口就是函数。
     C++语言-接口就是类的公有成员函数
     COM-接口就是一组纯虚函数的集合。COM组件通过接口对外提供
         服务。
     4.1 在程序中引入接口后，程序结构的变化
         interface是一种定义的类型，用来表示接口，本质是一个
         struct；只能包含纯虚函数。
         引入接口后，需求变更时，功能的提供者代码发生修改时，
         功能的使用者代码不用修改，但是整个工程仍需重新编译。
     4.2 将功能的提供者放到另外一个dll工程中，(dll接口)
      4.2.1 创建简单的win32 dll工程
      4.2.2 在工程中添加头文件math.h,在文件中添加接口的定义
      4.2.3 在工程中添加新的类CImpMath，实现IMath接口
            在工程中添加新的类CImpMath2，实现IMath接口 
      4.2.4 添加一个创建对象的函数CreateInstance
      4.2.5 在*.def文件中导出CreateInstance函数
     4.3 使用dll接口
        4.3.1 加载dll
        4.3.2 获取导出函数的函数地址
        4.3.3 根据导出函数的地址调用该函数，创建对象，
              返回接口
        4.3.4 通过接口调用接口函数
        注意：把dll文件和exe文件放到同一个bin目录下。
     把接口修改为dll接口，当功能的提供者发生变化时，功能
     的使用者代码无需修改，工程无需重新编辑，就可以使用
     新的功能。两者之间的耦合性降低了。
    5 解决第一个问题：对象的删除
     dll与exe分别拥有自己的堆空间。在dll中申请了内存，
     在exe释放了该内存，所以产生错误，结论是，只能在
     dll释放内存。
     5.1 引入一个引用计数，记录当前使用接口的用户数量；
     使用接口前，引用计数+1；使用接口后，引用计数-1；
     当引用计数为0，删除对象。
     5.1.1 在CImpMath中添加变量
           LONG m_nRef;//引用计数变量
     5.1.2 在IMath接口中添加接口函数
           ULONG AddRef()=0;
           ULONG Release()=0;
     5.1.3 在实现类CImpMath中实现这两个接口函数。
           注意：在多线程中使用原子锁的加减操作：
          InterlockedIncrement(&m_nRef);
 	  InterlockedDecrement(&m_nRef);


          
      
        
      
                 
      
     
                    
     
         
   
        


       

   